use crate::{ParsedResource, ParsedResourceReference, ResourceCodegenOptions};
use anyhow::Result;
use heck::{ToPascalCase, ToSnakeCase};
use proc_macro2::{Ident, TokenStream};
use quote::{format_ident, quote};
use resource_types::{ResourcePattern, ResourcePatternComponent};

/// Renderer for generating Rust code from parsed resources
pub struct ResourceRenderer;

impl ResourceRenderer {
    pub fn new() -> Self {
        Self
    }

    /// Render a complete file with resources and references
    pub fn render_file(
        &self,
        resources: &[ParsedResource],
        references: &[ParsedResourceReference],
        options: &ResourceCodegenOptions,
    ) -> Result<String> {
        let mut tokens = TokenStream::new();

        // Add standard imports
        tokens.extend(quote! {
            /// Generated resource name types and utilities.
            /// Do not edit - this file is automatically generated.

            use std::borrow::Borrow;
            use std::fmt::{self, Display};
            use std::str::FromStr;
            use resource_types::{ParseError, ResourceName};
        });

        // Generate each resource type
        for resource in resources {
            let resource_tokens = self.render_resource(resource)?;
            tokens.extend(resource_tokens);
        }

        // Generate extension traits if requested
        if options.generate_extensions {
            let ext_traits = self.render_extensions(references, resources)?;
            tokens.extend(ext_traits);
        }

        // Format the code using prettyplease
        let file = syn::parse_file(&tokens.to_string())?;
        Ok(prettyplease::unparse(&file))
    }

    /// Render a single resource type
    pub fn render_resource(&self, resource: &ParsedResource) -> Result<TokenStream> {
        let type_name = self.type_name_from_resource_type(&resource.type_name);
        let type_ident = format_ident!("{}", type_name);

        // For now, we'll assume single pattern. Multi-pattern support would be more complex.
        let pattern = &resource.patterns[0];
        let variables = self.extract_variables(pattern);

        let struct_def = self.render_struct(&type_ident, &variables);
        let impl_new = self.render_new_method(&type_ident, pattern, &variables);
        let impl_accessors = self.render_accessor_methods(&type_ident, &variables);
        let impl_traits = self.render_trait_impls(&type_ident, pattern);

        Ok(quote! {
            #struct_def
            #impl_new
            #impl_accessors
            #impl_traits
        })
    }

    fn render_struct(&self, type_ident: &Ident, _variables: &[String]) -> TokenStream {
        let doc = "A resource name for this resource type.".to_string();

        quote! {
            #[doc = #doc]
            #[derive(Debug, Clone, PartialEq, Eq, Hash)]
            pub struct #type_ident {
                inner: String,
            }
        }
    }

    fn render_new_method(
        &self,
        type_ident: &Ident,
        pattern: &ResourcePattern,
        variables: &[String],
    ) -> TokenStream {
        let method_params: Vec<_> = variables
            .iter()
            .map(|var| {
                let param_name = format_ident!("{}", var.to_snake_case());
                quote! { #param_name: impl Into<String> }
            })
            .collect();

        let format_args: Vec<_> = variables
            .iter()
            .map(|var| {
                let param_name = format_ident!("{}", var.to_snake_case());
                quote! { #param_name.into() }
            })
            .collect();

        // Create the format string from the pattern
        let format_str = self.pattern_to_format_string(pattern);

        quote! {
            impl #type_ident {
                /// Create a new resource name from its components.
                pub fn new(#(#method_params),*) -> Self {
                    Self {
                        inner: format!(#format_str, #(#format_args),*),
                    }
                }
            }
        }
    }

    fn render_accessor_methods(&self, type_ident: &Ident, variables: &[String]) -> TokenStream {
        let methods: Vec<_> = variables
            .iter()
            .enumerate()
            .map(|(i, var)| {
                let method_name = format_ident!("{}", var.to_snake_case());
                let doc = format!("Get the {var} component of this resource name.");

                quote! {
                    #[doc = #doc]
                    pub fn #method_name(&self) -> &str {
                        // This is a simplified implementation
                        // In a real implementation, you'd parse the string
                        // and extract the specific component
                        self.inner.split('/').nth(#i * 2 + 1).unwrap_or("")
                    }
                }
            })
            .collect();

        quote! {
            impl #type_ident {
                #(#methods)*
            }
        }
    }

    fn render_trait_impls(&self, type_ident: &Ident, pattern: &ResourcePattern) -> TokenStream {
        let pattern_str = &pattern.pattern;

        quote! {
            impl Display for #type_ident {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    write!(f, "{}", self.inner)
                }
            }

            impl AsRef<str> for #type_ident {
                fn as_ref(&self) -> &str {
                    &self.inner
                }
            }

            impl Borrow<str> for #type_ident {
                fn borrow(&self) -> &str {
                    &self.inner
                }
            }

            impl TryFrom<String> for #type_ident {
                type Error = ParseError;

                fn try_from(value: String) -> Result<Self, Self::Error> {
                    Self::from_str(&value).map_err(|_| ParseError::InvalidPattern {
                        value,
                        expected_pattern: #pattern_str.to_string(),
                    })
                }
            }

            impl TryFrom<&str> for #type_ident {
                type Error = ParseError;

                fn try_from(value: &str) -> Result<Self, Self::Error> {
                    Self::from_str(value).map_err(|_| ParseError::InvalidPattern {
                        value: value.to_string(),
                        expected_pattern: #pattern_str.to_string(),
                    })
                }
            }

            impl FromStr for #type_ident {
                type Err = ParseError;

                fn from_str(s: &str) -> Result<Self, Self::Err> {
                    // Simplified validation - would be more sophisticated in practice
                    if s.is_empty() {
                        return Err(ParseError::InvalidPattern {
                            value: s.to_string(),
                            expected_pattern: #pattern_str.to_string(),
                        });
                    }

                    Ok(Self {
                        inner: s.to_string(),
                    })
                }
            }

            impl From<#type_ident> for String {
                fn from(name: #type_ident) -> String {
                    name.inner
                }
            }

            impl ResourceName for #type_ident {
                fn pattern() -> &'static str {
                    #pattern_str
                }

                fn as_str(&self) -> &str {
                    &self.inner
                }
            }
        }
    }

    fn render_extensions(
        &self,
        references: &[ParsedResourceReference],
        resources: &[ParsedResource],
    ) -> Result<TokenStream> {
        // Group references by containing message
        let mut by_message = std::collections::HashMap::new();
        for reference in references {
            by_message
                .entry(&reference.containing_message)
                .or_insert_with(Vec::new)
                .push(reference);
        }

        let mut tokens = TokenStream::new();

        for (message_name, message_refs) in by_message {
            let trait_name = format_ident!("{}Ext", message_name.to_pascal_case());
            let struct_name = format_ident!("{}", message_name.to_pascal_case());

            let methods: Vec<_> = message_refs
                .iter()
                .filter_map(|r| {
                    let resource_type = r.resource_type.as_ref()?;
                    let _resource = resources
                        .iter()
                        .find(|res| &res.type_name == resource_type)?;
                    let type_name = self.type_name_from_resource_type(resource_type);
                    let type_ident = format_ident!("{}", type_name);
                    let field_name = format_ident!("{}", r.field_name.to_snake_case());
                    let getter_name = format_ident!("{}_typed", r.field_name.to_snake_case());
                    let setter_name = format_ident!("set_{}_typed", r.field_name.to_snake_case());

                    Some((
                        quote! {
                            /// Get the typed resource name for this field.
                            fn #getter_name(&self) -> Result<#type_ident, ParseError>;

                            /// Set this field from a typed resource name.
                            fn #setter_name(&mut self, value: #type_ident);
                        },
                        quote! {
                            /// Get the typed resource name for this field.
                            fn #getter_name(&self) -> Result<#type_ident, ParseError> {
                                #type_ident::try_from(self.#field_name.clone())
                            }

                            /// Set this field from a typed resource name.
                            fn #setter_name(&mut self, value: #type_ident) {
                                self.#field_name = value.into();
                            }
                        },
                    ))
                })
                .collect();

            if !methods.is_empty() {
                let trait_methods: Vec<_> = methods
                    .iter()
                    .map(|(trait_method, _)| trait_method)
                    .collect();
                let impl_methods: Vec<_> =
                    methods.iter().map(|(_, impl_method)| impl_method).collect();

                tokens.extend(quote! {
                    /// Extension trait for accessing typed resource names.
                    pub trait #trait_name {
                        #(#trait_methods)*
                    }

                    impl #trait_name for #struct_name {
                        #(#impl_methods)*
                    }
                });
            }
        }

        Ok(tokens)
    }

    /// Extract variable names from a pattern
    fn extract_variables(&self, pattern: &ResourcePattern) -> Vec<String> {
        pattern
            .components
            .iter()
            .filter_map(|component| match component {
                ResourcePatternComponent::Variable(name) => Some(name.clone()),
                _ => None,
            })
            .collect()
    }

    /// Convert a resource type to a Rust type name
    fn type_name_from_resource_type(&self, resource_type: &str) -> String {
        // Extract the last part after the last '/'
        let last_part = resource_type
            .split('/')
            .next_back()
            .unwrap_or(resource_type);
        format!("{}Name", last_part.to_pascal_case())
    }

    /// Convert a pattern to a format string for use with format!()
    fn pattern_to_format_string(&self, pattern: &ResourcePattern) -> String {
        let mut result = String::new();
        for component in &pattern.components {
            match component {
                ResourcePatternComponent::Literal(literal) => result.push_str(literal),
                ResourcePatternComponent::Variable(_) => result.push_str("{}"),
            }
        }
        result
    }
}

impl Default for ResourceRenderer {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use resource_types::ResourcePatternComponent;

    #[test]
    fn test_type_name_from_resource_type() {
        let renderer = ResourceRenderer::new();
        assert_eq!(
            renderer.type_name_from_resource_type("pubsub.googleapis.com/Topic"),
            "TopicName"
        );
        assert_eq!(
            renderer.type_name_from_resource_type("storage.googleapis.com/Bucket"),
            "BucketName"
        );
    }

    #[test]
    fn test_extract_variables() {
        let renderer = ResourceRenderer::new();
        let pattern = ResourcePattern {
            pattern: "projects/{project}/topics/{topic}".to_string(),
            components: vec![
                ResourcePatternComponent::Literal("projects/".to_string()),
                ResourcePatternComponent::Variable("project".to_string()),
                ResourcePatternComponent::Literal("/topics/".to_string()),
                ResourcePatternComponent::Variable("topic".to_string()),
            ],
        };

        let variables = renderer.extract_variables(&pattern);
        assert_eq!(variables, vec!["project", "topic"]);
    }

    #[test]
    fn test_pattern_to_format_string() {
        let renderer = ResourceRenderer::new();
        let pattern = ResourcePattern {
            pattern: "projects/{project}/topics/{topic}".to_string(),
            components: vec![
                ResourcePatternComponent::Literal("projects/".to_string()),
                ResourcePatternComponent::Variable("project".to_string()),
                ResourcePatternComponent::Literal("/topics/".to_string()),
                ResourcePatternComponent::Variable("topic".to_string()),
            ],
        };

        let format_str = renderer.pattern_to_format_string(&pattern);
        assert_eq!(format_str, "projects/{}/topics/{}");
    }
}
