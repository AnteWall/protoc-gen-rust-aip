//! Comprehensive example showcasing all resource name patterns
//! 
//! This example demonstrates:
//! - Basic resource patterns (single pattern)
//! - Collection ID patterns (nested resources)
//! - Multi-pattern resources (multiple valid patterns per type)
//! - Resource references (cross-resource relationships)
//! - Extension traits for typed resource access

use std::collections::HashMap;

// Import the generated code
mod gen {
    include!("../gen/example.comprehensive.v1.rs");
    include!("../gen/resources_resources.rs");
}

use gen::*;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== Comprehensive Resource Name Examples ===\n");
    
    basic_resource_patterns()?;
    collection_id_patterns()?;
    multi_pattern_resources()?;
    resource_references()?;
    
    Ok(())
}

/// Demonstrates basic resource patterns with single patterns
fn basic_resource_patterns() -> Result<(), Box<dyn std::error::Error>> {
    println!("1. BASIC RESOURCE PATTERNS");
    println!("   Simple patterns with basic variable substitution\n");
    
    // Project resource: projects/{project}
    let project_name = ProjectName::new("my-project");
    println!("   Project: {}", project_name);
    println!("   Project ID: {}", project_name.project());
    
    // Topic resource: projects/{project}/topics/{topic}
    let topic_name = TopicName::new("my-project", "notifications");
    println!("   Topic: {}", topic_name);
    println!("   Project: {}", topic_name.project());
    println!("   Topic: {}", topic_name.topic());
    
    // Bucket resource: projects/{project}/buckets/{bucket}
    let bucket_name = BucketName::new("my-project", "media-files");
    println!("   Bucket: {}", bucket_name);
    println!("   Project: {}", bucket_name.project());
    println!("   Bucket: {}", bucket_name.bucket());
    
    println!();
    Ok(())
}

/// Demonstrates collection ID patterns (nested resources)
fn collection_id_patterns() -> Result<(), Box<dyn std::error::Error>> {
    println!("2. COLLECTION ID PATTERNS");
    println!("   Nested resources with collection identifiers\n");
    
    // User resource: users/{user_id}
    let user_name = UserName::new("alice");
    println!("   User: {}", user_name);
    println!("   User ID: {}", user_name.user_id());
    
    // Document resource: users/{user_id}/documents/{document_id}
    let doc_name = DocumentName::new("alice", "my-document");
    println!("   Document: {}", doc_name);
    println!("   User ID: {}", doc_name.user_id());
    println!("   Document ID: {}", doc_name.document_id());
    
    // Database resource: projects/{project}/instances/{instance}/databases/{database}
    let db_name = DatabaseName::new("my-project", "my-instance", "my-database");
    println!("   Database: {}", db_name);
    println!("   Project: {}", db_name.project());
    println!("   Instance: {}", db_name.instance());
    println!("   Database: {}", db_name.database());
    
    println!();
    Ok(())
}

/// Demonstrates multi-pattern resources (resources with multiple valid patterns)
fn multi_pattern_resources() -> Result<(), Box<dyn std::error::Error>> {
    println!("3. MULTI-PATTERN RESOURCES");
    println!("   Resources that support multiple valid naming patterns\n");
    
    // Instance resource with zone pattern: projects/{project}/zones/{zone}/instances/{instance}
    let zone_instance = InstanceName::new("my-project", "us-central1-a", "web-server-1");
    println!("   Zone Instance: {}", zone_instance);
    println!("   Project: {}", zone_instance.project());
    println!("   Zone: {}", zone_instance.zone());
    println!("   Instance: {}", zone_instance.instance());
    
    // Note: Current dynamic parser only generates one pattern per resource
    // In a real implementation with proper annotation parsing, you'd have multiple patterns
    println!("   (Note: Region pattern not generated by current simplified parser)");
    
    // Parse existing instance names to see pattern detection
    let zone_str = "projects/test/zones/us-west1-b/instances/worker";
    if let Ok(parsed_zone) = InstanceName::try_from(zone_str.to_string()) {
        println!("   Parsed zone instance: {}", parsed_zone);
        println!("   Detected zone: {}", parsed_zone.zone());
    }
    
    println!();
    Ok(())
}

/// Demonstrates resource references and extension traits
fn resource_references() -> Result<(), Box<dyn std::error::Error>> {
    println!("4. RESOURCE REFERENCES");
    println!("   Cross-resource relationships and typed access\n");
    
    // Create resources with extension trait usage
    let topic = Topic {
        name: "projects/my-project/topics/user-events".to_string(),
        display_name: "User Events Topic".to_string(),
        labels: HashMap::new(),
    };
    
    // Use extension trait to get typed name
    if let Ok(topic_name) = topic.name_typed() {
        println!("   Topic: {}", topic.name);
        println!("   Project: {}", topic_name.project());
        println!("   Topic: {}", topic_name.topic());
    }
    
    // User resource usage
    let user = User {
        name: "users/bob".to_string(),
        display_name: "Bob Smith".to_string(),
        email: "bob@example.com".to_string(),
    };
    
    if let Ok(user_name) = user.name_typed() {
        println!("   User: {}", user.name);
        println!("   User ID: {}", user_name.user_id());
    }
    
    // Create a document with references
    let document = Document {
        name: "users/alice/documents/my-doc".to_string(),
        title: "My Document".to_string(),
        content: "Hello, world!".to_string(),
        owner: "users/alice".to_string(),
    };
    
    if let Ok(doc_name) = document.name_typed() {
        println!("   Document: {}", document.name);
        println!("   Document ID: {}", doc_name.document_id());
        
        // Parse the owner field manually since it doesn't have a generated extension
        if let Ok(owner_name) = UserName::try_from(document.owner.clone()) {
            println!("   Owner: {} (user: {})", document.owner, owner_name.user_id());
        }
    }
    
    // Create a complex object with nested references
    let object = Object {
        name: "projects/my-project/buckets/my-bucket/objects/photo.jpg".to_string(),
        content_type: "image/jpeg".to_string(),
        size: 1024,
        bucket: "projects/my-project/buckets/my-bucket".to_string(),
    };
    
    // Parse the object name directly
    if let Ok(obj_name) = ObjectName::try_from(object.name.clone()) {
        println!("   Object: {}", object.name);
        println!("   Project: {}", obj_name.project());
        println!("   Bucket: {}", obj_name.bucket());
        println!("   Object: {}", obj_name.object());
        
        // Access the bucket reference through extension trait
        if let Ok(bucket_name) = object.bucket_typed() {
            println!("   Bucket reference: {} (bucket: {})", 
                     object.bucket, bucket_name.bucket());
        }
    }
    
    println!();
    Ok(())
}
