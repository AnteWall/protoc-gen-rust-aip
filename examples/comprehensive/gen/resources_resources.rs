/// Generated resource name types and utilities.
/// Do not edit - this file is automatically generated.
use std::borrow::Borrow;
use std::fmt::{self, Display};
use std::str::FromStr;
use resource_types::{ParseError, ResourceName};
///A resource name for this resource type.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DocumentName {
    inner: String,
}
impl DocumentName {
    /// Create a new resource name from its components.
    pub fn new(user_id: impl Into<String>, document_id: impl Into<String>) -> Self {
        Self {
            inner: format!("users/{}/documents/{}", user_id.into(), document_id.into()),
        }
    }
}
impl DocumentName {
    ///Get the user_id component of this resource name.
    pub fn user_id(&self) -> &str {
        self.inner.split('/').nth(0usize * 2 + 1).unwrap_or("")
    }
    ///Get the document_id component of this resource name.
    pub fn document_id(&self) -> &str {
        self.inner.split('/').nth(1usize * 2 + 1).unwrap_or("")
    }
}
impl Display for DocumentName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.inner)
    }
}
impl AsRef<str> for DocumentName {
    fn as_ref(&self) -> &str {
        &self.inner
    }
}
impl Borrow<str> for DocumentName {
    fn borrow(&self) -> &str {
        &self.inner
    }
}
impl TryFrom<String> for DocumentName {
    type Error = ParseError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::from_str(&value)
            .map_err(|_| ParseError::InvalidPattern {
                value,
                expected_pattern: "users/{user_id}/documents/{document_id}".to_string(),
            })
    }
}
impl TryFrom<&str> for DocumentName {
    type Error = ParseError;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        Self::from_str(value)
            .map_err(|_| ParseError::InvalidPattern {
                value: value.to_string(),
                expected_pattern: "users/{user_id}/documents/{document_id}".to_string(),
            })
    }
}
impl FromStr for DocumentName {
    type Err = ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.is_empty() {
            return Err(ParseError::InvalidPattern {
                value: s.to_string(),
                expected_pattern: "users/{user_id}/documents/{document_id}".to_string(),
            });
        }
        Ok(Self { inner: s.to_string() })
    }
}
impl From<DocumentName> for String {
    fn from(name: DocumentName) -> String {
        name.inner
    }
}
impl ResourceName for DocumentName {
    fn pattern() -> &'static str {
        "users/{user_id}/documents/{document_id}"
    }
    fn as_str(&self) -> &str {
        &self.inner
    }
}
///A resource name for this resource type.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UserName {
    inner: String,
}
impl UserName {
    /// Create a new resource name from its components.
    pub fn new(user_id: impl Into<String>) -> Self {
        Self {
            inner: format!("users/{}", user_id.into()),
        }
    }
}
impl UserName {
    ///Get the user_id component of this resource name.
    pub fn user_id(&self) -> &str {
        self.inner.split('/').nth(0usize * 2 + 1).unwrap_or("")
    }
}
impl Display for UserName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.inner)
    }
}
impl AsRef<str> for UserName {
    fn as_ref(&self) -> &str {
        &self.inner
    }
}
impl Borrow<str> for UserName {
    fn borrow(&self) -> &str {
        &self.inner
    }
}
impl TryFrom<String> for UserName {
    type Error = ParseError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::from_str(&value)
            .map_err(|_| ParseError::InvalidPattern {
                value,
                expected_pattern: "users/{user_id}".to_string(),
            })
    }
}
impl TryFrom<&str> for UserName {
    type Error = ParseError;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        Self::from_str(value)
            .map_err(|_| ParseError::InvalidPattern {
                value: value.to_string(),
                expected_pattern: "users/{user_id}".to_string(),
            })
    }
}
impl FromStr for UserName {
    type Err = ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.is_empty() {
            return Err(ParseError::InvalidPattern {
                value: s.to_string(),
                expected_pattern: "users/{user_id}".to_string(),
            });
        }
        Ok(Self { inner: s.to_string() })
    }
}
impl From<UserName> for String {
    fn from(name: UserName) -> String {
        name.inner
    }
}
impl ResourceName for UserName {
    fn pattern() -> &'static str {
        "users/{user_id}"
    }
    fn as_str(&self) -> &str {
        &self.inner
    }
}
///A resource name for this resource type.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DatabaseName {
    inner: String,
}
impl DatabaseName {
    /// Create a new resource name from its components.
    pub fn new(
        project: impl Into<String>,
        instance: impl Into<String>,
        database: impl Into<String>,
    ) -> Self {
        Self {
            inner: format!(
                "projects/{}/instances/{}/databases/{}", project.into(), instance.into(),
                database.into()
            ),
        }
    }
}
impl DatabaseName {
    ///Get the project component of this resource name.
    pub fn project(&self) -> &str {
        self.inner.split('/').nth(0usize * 2 + 1).unwrap_or("")
    }
    ///Get the instance component of this resource name.
    pub fn instance(&self) -> &str {
        self.inner.split('/').nth(1usize * 2 + 1).unwrap_or("")
    }
    ///Get the database component of this resource name.
    pub fn database(&self) -> &str {
        self.inner.split('/').nth(2usize * 2 + 1).unwrap_or("")
    }
}
impl Display for DatabaseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.inner)
    }
}
impl AsRef<str> for DatabaseName {
    fn as_ref(&self) -> &str {
        &self.inner
    }
}
impl Borrow<str> for DatabaseName {
    fn borrow(&self) -> &str {
        &self.inner
    }
}
impl TryFrom<String> for DatabaseName {
    type Error = ParseError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::from_str(&value)
            .map_err(|_| ParseError::InvalidPattern {
                value,
                expected_pattern: "projects/{project}/instances/{instance}/databases/{database}"
                    .to_string(),
            })
    }
}
impl TryFrom<&str> for DatabaseName {
    type Error = ParseError;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        Self::from_str(value)
            .map_err(|_| ParseError::InvalidPattern {
                value: value.to_string(),
                expected_pattern: "projects/{project}/instances/{instance}/databases/{database}"
                    .to_string(),
            })
    }
}
impl FromStr for DatabaseName {
    type Err = ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.is_empty() {
            return Err(ParseError::InvalidPattern {
                value: s.to_string(),
                expected_pattern: "projects/{project}/instances/{instance}/databases/{database}"
                    .to_string(),
            });
        }
        Ok(Self { inner: s.to_string() })
    }
}
impl From<DatabaseName> for String {
    fn from(name: DatabaseName) -> String {
        name.inner
    }
}
impl ResourceName for DatabaseName {
    fn pattern() -> &'static str {
        "projects/{project}/instances/{instance}/databases/{database}"
    }
    fn as_str(&self) -> &str {
        &self.inner
    }
}
///A resource name for this resource type.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BucketName {
    inner: String,
}
impl BucketName {
    /// Create a new resource name from its components.
    pub fn new(project: impl Into<String>, bucket: impl Into<String>) -> Self {
        Self {
            inner: format!("projects/{}/buckets/{}", project.into(), bucket.into()),
        }
    }
}
impl BucketName {
    ///Get the project component of this resource name.
    pub fn project(&self) -> &str {
        self.inner.split('/').nth(0usize * 2 + 1).unwrap_or("")
    }
    ///Get the bucket component of this resource name.
    pub fn bucket(&self) -> &str {
        self.inner.split('/').nth(1usize * 2 + 1).unwrap_or("")
    }
}
impl Display for BucketName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.inner)
    }
}
impl AsRef<str> for BucketName {
    fn as_ref(&self) -> &str {
        &self.inner
    }
}
impl Borrow<str> for BucketName {
    fn borrow(&self) -> &str {
        &self.inner
    }
}
impl TryFrom<String> for BucketName {
    type Error = ParseError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::from_str(&value)
            .map_err(|_| ParseError::InvalidPattern {
                value,
                expected_pattern: "projects/{project}/buckets/{bucket}".to_string(),
            })
    }
}
impl TryFrom<&str> for BucketName {
    type Error = ParseError;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        Self::from_str(value)
            .map_err(|_| ParseError::InvalidPattern {
                value: value.to_string(),
                expected_pattern: "projects/{project}/buckets/{bucket}".to_string(),
            })
    }
}
impl FromStr for BucketName {
    type Err = ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.is_empty() {
            return Err(ParseError::InvalidPattern {
                value: s.to_string(),
                expected_pattern: "projects/{project}/buckets/{bucket}".to_string(),
            });
        }
        Ok(Self { inner: s.to_string() })
    }
}
impl From<BucketName> for String {
    fn from(name: BucketName) -> String {
        name.inner
    }
}
impl ResourceName for BucketName {
    fn pattern() -> &'static str {
        "projects/{project}/buckets/{bucket}"
    }
    fn as_str(&self) -> &str {
        &self.inner
    }
}
///A resource name for this resource type.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ObjectName {
    inner: String,
}
impl ObjectName {
    /// Create a new resource name from its components.
    pub fn new(
        project: impl Into<String>,
        bucket: impl Into<String>,
        object: impl Into<String>,
    ) -> Self {
        Self {
            inner: format!(
                "projects/{}/buckets/{}/objects/{}", project.into(), bucket.into(),
                object.into()
            ),
        }
    }
}
impl ObjectName {
    ///Get the project component of this resource name.
    pub fn project(&self) -> &str {
        self.inner.split('/').nth(0usize * 2 + 1).unwrap_or("")
    }
    ///Get the bucket component of this resource name.
    pub fn bucket(&self) -> &str {
        self.inner.split('/').nth(1usize * 2 + 1).unwrap_or("")
    }
    ///Get the object component of this resource name.
    pub fn object(&self) -> &str {
        self.inner.split('/').nth(2usize * 2 + 1).unwrap_or("")
    }
}
impl Display for ObjectName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.inner)
    }
}
impl AsRef<str> for ObjectName {
    fn as_ref(&self) -> &str {
        &self.inner
    }
}
impl Borrow<str> for ObjectName {
    fn borrow(&self) -> &str {
        &self.inner
    }
}
impl TryFrom<String> for ObjectName {
    type Error = ParseError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::from_str(&value)
            .map_err(|_| ParseError::InvalidPattern {
                value,
                expected_pattern: "projects/{project}/buckets/{bucket}/objects/{object}"
                    .to_string(),
            })
    }
}
impl TryFrom<&str> for ObjectName {
    type Error = ParseError;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        Self::from_str(value)
            .map_err(|_| ParseError::InvalidPattern {
                value: value.to_string(),
                expected_pattern: "projects/{project}/buckets/{bucket}/objects/{object}"
                    .to_string(),
            })
    }
}
impl FromStr for ObjectName {
    type Err = ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.is_empty() {
            return Err(ParseError::InvalidPattern {
                value: s.to_string(),
                expected_pattern: "projects/{project}/buckets/{bucket}/objects/{object}"
                    .to_string(),
            });
        }
        Ok(Self { inner: s.to_string() })
    }
}
impl From<ObjectName> for String {
    fn from(name: ObjectName) -> String {
        name.inner
    }
}
impl ResourceName for ObjectName {
    fn pattern() -> &'static str {
        "projects/{project}/buckets/{bucket}/objects/{object}"
    }
    fn as_str(&self) -> &str {
        &self.inner
    }
}
///A resource name for this resource type.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InstanceName {
    inner: String,
}
impl InstanceName {
    /// Create a new resource name from its components.
    pub fn new(
        project: impl Into<String>,
        zone: impl Into<String>,
        instance: impl Into<String>,
    ) -> Self {
        Self {
            inner: format!(
                "projects/{}/zones/{}/instances/{}", project.into(), zone.into(),
                instance.into()
            ),
        }
    }
}
impl InstanceName {
    ///Get the project component of this resource name.
    pub fn project(&self) -> &str {
        self.inner.split('/').nth(0usize * 2 + 1).unwrap_or("")
    }
    ///Get the zone component of this resource name.
    pub fn zone(&self) -> &str {
        self.inner.split('/').nth(1usize * 2 + 1).unwrap_or("")
    }
    ///Get the instance component of this resource name.
    pub fn instance(&self) -> &str {
        self.inner.split('/').nth(2usize * 2 + 1).unwrap_or("")
    }
}
impl Display for InstanceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.inner)
    }
}
impl AsRef<str> for InstanceName {
    fn as_ref(&self) -> &str {
        &self.inner
    }
}
impl Borrow<str> for InstanceName {
    fn borrow(&self) -> &str {
        &self.inner
    }
}
impl TryFrom<String> for InstanceName {
    type Error = ParseError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::from_str(&value)
            .map_err(|_| ParseError::InvalidPattern {
                value,
                expected_pattern: "projects/{project}/zones/{zone}/instances/{instance}"
                    .to_string(),
            })
    }
}
impl TryFrom<&str> for InstanceName {
    type Error = ParseError;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        Self::from_str(value)
            .map_err(|_| ParseError::InvalidPattern {
                value: value.to_string(),
                expected_pattern: "projects/{project}/zones/{zone}/instances/{instance}"
                    .to_string(),
            })
    }
}
impl FromStr for InstanceName {
    type Err = ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.is_empty() {
            return Err(ParseError::InvalidPattern {
                value: s.to_string(),
                expected_pattern: "projects/{project}/zones/{zone}/instances/{instance}"
                    .to_string(),
            });
        }
        Ok(Self { inner: s.to_string() })
    }
}
impl From<InstanceName> for String {
    fn from(name: InstanceName) -> String {
        name.inner
    }
}
impl ResourceName for InstanceName {
    fn pattern() -> &'static str {
        "projects/{project}/zones/{zone}/instances/{instance}"
    }
    fn as_str(&self) -> &str {
        &self.inner
    }
}
///A resource name for this resource type.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ProjectName {
    inner: String,
}
impl ProjectName {
    /// Create a new resource name from its components.
    pub fn new(project: impl Into<String>) -> Self {
        Self {
            inner: format!("projects/{}", project.into()),
        }
    }
}
impl ProjectName {
    ///Get the project component of this resource name.
    pub fn project(&self) -> &str {
        self.inner.split('/').nth(0usize * 2 + 1).unwrap_or("")
    }
}
impl Display for ProjectName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.inner)
    }
}
impl AsRef<str> for ProjectName {
    fn as_ref(&self) -> &str {
        &self.inner
    }
}
impl Borrow<str> for ProjectName {
    fn borrow(&self) -> &str {
        &self.inner
    }
}
impl TryFrom<String> for ProjectName {
    type Error = ParseError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::from_str(&value)
            .map_err(|_| ParseError::InvalidPattern {
                value,
                expected_pattern: "projects/{project}".to_string(),
            })
    }
}
impl TryFrom<&str> for ProjectName {
    type Error = ParseError;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        Self::from_str(value)
            .map_err(|_| ParseError::InvalidPattern {
                value: value.to_string(),
                expected_pattern: "projects/{project}".to_string(),
            })
    }
}
impl FromStr for ProjectName {
    type Err = ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.is_empty() {
            return Err(ParseError::InvalidPattern {
                value: s.to_string(),
                expected_pattern: "projects/{project}".to_string(),
            });
        }
        Ok(Self { inner: s.to_string() })
    }
}
impl From<ProjectName> for String {
    fn from(name: ProjectName) -> String {
        name.inner
    }
}
impl ResourceName for ProjectName {
    fn pattern() -> &'static str {
        "projects/{project}"
    }
    fn as_str(&self) -> &str {
        &self.inner
    }
}
///A resource name for this resource type.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TopicName {
    inner: String,
}
impl TopicName {
    /// Create a new resource name from its components.
    pub fn new(project: impl Into<String>, topic: impl Into<String>) -> Self {
        Self {
            inner: format!("projects/{}/topics/{}", project.into(), topic.into()),
        }
    }
}
impl TopicName {
    ///Get the project component of this resource name.
    pub fn project(&self) -> &str {
        self.inner.split('/').nth(0usize * 2 + 1).unwrap_or("")
    }
    ///Get the topic component of this resource name.
    pub fn topic(&self) -> &str {
        self.inner.split('/').nth(1usize * 2 + 1).unwrap_or("")
    }
}
impl Display for TopicName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.inner)
    }
}
impl AsRef<str> for TopicName {
    fn as_ref(&self) -> &str {
        &self.inner
    }
}
impl Borrow<str> for TopicName {
    fn borrow(&self) -> &str {
        &self.inner
    }
}
impl TryFrom<String> for TopicName {
    type Error = ParseError;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::from_str(&value)
            .map_err(|_| ParseError::InvalidPattern {
                value,
                expected_pattern: "projects/{project}/topics/{topic}".to_string(),
            })
    }
}
impl TryFrom<&str> for TopicName {
    type Error = ParseError;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        Self::from_str(value)
            .map_err(|_| ParseError::InvalidPattern {
                value: value.to_string(),
                expected_pattern: "projects/{project}/topics/{topic}".to_string(),
            })
    }
}
impl FromStr for TopicName {
    type Err = ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.is_empty() {
            return Err(ParseError::InvalidPattern {
                value: s.to_string(),
                expected_pattern: "projects/{project}/topics/{topic}".to_string(),
            });
        }
        Ok(Self { inner: s.to_string() })
    }
}
impl From<TopicName> for String {
    fn from(name: TopicName) -> String {
        name.inner
    }
}
impl ResourceName for TopicName {
    fn pattern() -> &'static str {
        "projects/{project}/topics/{topic}"
    }
    fn as_str(&self) -> &str {
        &self.inner
    }
}
/// Extension trait for accessing typed resource names.
pub trait DocumentExt {
    /// Get the typed resource name for this field.
    fn name_typed(&self) -> Result<DocumentName, ParseError>;
    /// Set this field from a typed resource name.
    fn set_name_typed(&mut self, value: DocumentName);
}
impl DocumentExt for Document {
    /// Get the typed resource name for this field.
    fn name_typed(&self) -> Result<DocumentName, ParseError> {
        DocumentName::try_from(self.name.clone())
    }
    /// Set this field from a typed resource name.
    fn set_name_typed(&mut self, value: DocumentName) {
        self.name = value.into();
    }
}
/// Extension trait for accessing typed resource names.
pub trait BucketExt {
    /// Get the typed resource name for this field.
    fn project_typed(&self) -> Result<ProjectName, ParseError>;
    /// Set this field from a typed resource name.
    fn set_project_typed(&mut self, value: ProjectName);
}
impl BucketExt for Bucket {
    /// Get the typed resource name for this field.
    fn project_typed(&self) -> Result<ProjectName, ParseError> {
        ProjectName::try_from(self.project.clone())
    }
    /// Set this field from a typed resource name.
    fn set_project_typed(&mut self, value: ProjectName) {
        self.project = value.into();
    }
}
/// Extension trait for accessing typed resource names.
pub trait DatabaseExt {
    /// Get the typed resource name for this field.
    fn name_typed(&self) -> Result<DatabaseName, ParseError>;
    /// Set this field from a typed resource name.
    fn set_name_typed(&mut self, value: DatabaseName);
}
impl DatabaseExt for Database {
    /// Get the typed resource name for this field.
    fn name_typed(&self) -> Result<DatabaseName, ParseError> {
        DatabaseName::try_from(self.name.clone())
    }
    /// Set this field from a typed resource name.
    fn set_name_typed(&mut self, value: DatabaseName) {
        self.name = value.into();
    }
}
/// Extension trait for accessing typed resource names.
pub trait InstanceExt {
    /// Get the typed resource name for this field.
    fn name_typed(&self) -> Result<InstanceName, ParseError>;
    /// Set this field from a typed resource name.
    fn set_name_typed(&mut self, value: InstanceName);
}
impl InstanceExt for Instance {
    /// Get the typed resource name for this field.
    fn name_typed(&self) -> Result<InstanceName, ParseError> {
        InstanceName::try_from(self.name.clone())
    }
    /// Set this field from a typed resource name.
    fn set_name_typed(&mut self, value: InstanceName) {
        self.name = value.into();
    }
}
/// Extension trait for accessing typed resource names.
pub trait UserExt {
    /// Get the typed resource name for this field.
    fn name_typed(&self) -> Result<UserName, ParseError>;
    /// Set this field from a typed resource name.
    fn set_name_typed(&mut self, value: UserName);
}
impl UserExt for User {
    /// Get the typed resource name for this field.
    fn name_typed(&self) -> Result<UserName, ParseError> {
        UserName::try_from(self.name.clone())
    }
    /// Set this field from a typed resource name.
    fn set_name_typed(&mut self, value: UserName) {
        self.name = value.into();
    }
}
/// Extension trait for accessing typed resource names.
pub trait TopicExt {
    /// Get the typed resource name for this field.
    fn name_typed(&self) -> Result<TopicName, ParseError>;
    /// Set this field from a typed resource name.
    fn set_name_typed(&mut self, value: TopicName);
}
impl TopicExt for Topic {
    /// Get the typed resource name for this field.
    fn name_typed(&self) -> Result<TopicName, ParseError> {
        TopicName::try_from(self.name.clone())
    }
    /// Set this field from a typed resource name.
    fn set_name_typed(&mut self, value: TopicName) {
        self.name = value.into();
    }
}
/// Extension trait for accessing typed resource names.
pub trait ObjectExt {
    /// Get the typed resource name for this field.
    fn bucket_typed(&self) -> Result<BucketName, ParseError>;
    /// Set this field from a typed resource name.
    fn set_bucket_typed(&mut self, value: BucketName);
}
impl ObjectExt for Object {
    /// Get the typed resource name for this field.
    fn bucket_typed(&self) -> Result<BucketName, ParseError> {
        BucketName::try_from(self.bucket.clone())
    }
    /// Set this field from a typed resource name.
    fn set_bucket_typed(&mut self, value: BucketName) {
        self.bucket = value.into();
    }
}
