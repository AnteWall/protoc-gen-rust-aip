// Code generated by protoc-gen-rust-aip. DO NOT EDIT.
//
// versions:
// 	protoc-gen-rust-aip development
// 	protoc (unknown)
// source: library.proto

use std::fmt;
use std::str::FromStr;

/// Resource name for library.googleapis.com/Book
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BookResourceName {
    pub project: String,
    pub book: String,
}

impl BookResourceName {
    /// Creates a new BookResourceName.
    pub fn new(
        project: impl Into<String>,
        book: impl Into<String>
    ) -> Self {
        Self {
            project: project.into(),
            book: book.into(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        if self.project.is_empty() {
            return Err("project: empty".to_string());
        }
        if self.project.contains('/') {
            return Err("project: contains illegal character '/'".to_string());
        }
        if self.book.is_empty() {
            return Err("book: empty".to_string());
        }
        if self.book.contains('/') {
            return Err("book: contains illegal character '/'".to_string());
        }
        Ok(())
    }

    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "library.googleapis.com/Book"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        self.project == "-" || self.book == "-"
    }

}

impl fmt::Display for BookResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "projects/{project}/books/{book}"
            , project = self.project
            , book = self.book
        )
    }
}

impl FromStr for BookResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.split('/').collect();
        if parts.len() != 4 {
            return Err(format!("expected {expected_parts} parts, got {}", parts.len(), expected_parts = 4));
        }
        if parts[0] != "projects" {
            return Err(format!("expected 'projects' at position 0, got '{part}'", part = parts[0]));
        }
        let project = parts[1].to_string();
        if parts[2] != "books" {
            return Err(format!("expected 'books' at position 2, got '{part}'", part = parts[2]));
        }
        let book = parts[3].to_string();
        let result = Self {
            project,
            book,
        };
        result.validate()?;
        Ok(result)
    }
}

/// Multi-pattern resource name for library.googleapis.com/Shelf
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ShelfResourceName {
    Projects(ProjectsShelfResourceName),
    Users(UsersShelfResourceName),
}

impl ShelfResourceName {
    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "library.googleapis.com/Shelf"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        match self {
            ShelfResourceName::Projects(inner) => inner.contains_wildcard(),
            ShelfResourceName::Users(inner) => inner.contains_wildcard(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        match self {
            ShelfResourceName::Projects(inner) => inner.validate(),
            ShelfResourceName::Users(inner) => inner.validate(),
        }
    }
}

impl fmt::Display for ShelfResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ShelfResourceName::Projects(inner) => write!(f, "{inner}"),
            ShelfResourceName::Users(inner) => write!(f, "{inner}"),
        }
    }
}

impl FromStr for ShelfResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Ok(parsed) = ProjectsShelfResourceName::from_str(s) {
            return Ok(ShelfResourceName::Projects(parsed));
        }
        if let Ok(parsed) = UsersShelfResourceName::from_str(s) {
            return Ok(ShelfResourceName::Users(parsed));
        }
        Err("no matching pattern".to_string())
    }
}

/// Parses a resource name string and returns the appropriate type.
pub fn parse_shelf_resource_name(name: &str) -> Result<ShelfResourceName, String> {
    ShelfResourceName::from_str(name)
}

/// Resource name for library.googleapis.com/Shelf
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ProjectsShelfResourceName {
    pub project: String,
    pub shelf: String,
}

impl ProjectsShelfResourceName {
    /// Creates a new ProjectsShelfResourceName.
    pub fn new(
        project: impl Into<String>,
        shelf: impl Into<String>
    ) -> Self {
        Self {
            project: project.into(),
            shelf: shelf.into(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        if self.project.is_empty() {
            return Err("project: empty".to_string());
        }
        if self.project.contains('/') {
            return Err("project: contains illegal character '/'".to_string());
        }
        if self.shelf.is_empty() {
            return Err("shelf: empty".to_string());
        }
        if self.shelf.contains('/') {
            return Err("shelf: contains illegal character '/'".to_string());
        }
        Ok(())
    }

    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "library.googleapis.com/Shelf"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        self.project == "-" || self.shelf == "-"
    }

}

impl fmt::Display for ProjectsShelfResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "projects/{project}/shelves/{shelf}"
            , project = self.project
            , shelf = self.shelf
        )
    }
}

impl FromStr for ProjectsShelfResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.split('/').collect();
        if parts.len() != 4 {
            return Err(format!("expected {expected_parts} parts, got {}", parts.len(), expected_parts = 4));
        }
        if parts[0] != "projects" {
            return Err(format!("expected 'projects' at position 0, got '{part}'", part = parts[0]));
        }
        let project = parts[1].to_string();
        if parts[2] != "shelves" {
            return Err(format!("expected 'shelves' at position 2, got '{part}'", part = parts[2]));
        }
        let shelf = parts[3].to_string();
        let result = Self {
            project,
            shelf,
        };
        result.validate()?;
        Ok(result)
    }
}

/// Resource name for library.googleapis.com/Shelf
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UsersShelfResourceName {
    pub user: String,
    pub shelf: String,
}

impl UsersShelfResourceName {
    /// Creates a new UsersShelfResourceName.
    pub fn new(
        user: impl Into<String>,
        shelf: impl Into<String>
    ) -> Self {
        Self {
            user: user.into(),
            shelf: shelf.into(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        if self.user.is_empty() {
            return Err("user: empty".to_string());
        }
        if self.user.contains('/') {
            return Err("user: contains illegal character '/'".to_string());
        }
        if self.shelf.is_empty() {
            return Err("shelf: empty".to_string());
        }
        if self.shelf.contains('/') {
            return Err("shelf: contains illegal character '/'".to_string());
        }
        Ok(())
    }

    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "library.googleapis.com/Shelf"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        self.user == "-" || self.shelf == "-"
    }

}

impl fmt::Display for UsersShelfResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "users/{user}/shelves/{shelf}"
            , user = self.user
            , shelf = self.shelf
        )
    }
}

impl FromStr for UsersShelfResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.split('/').collect();
        if parts.len() != 4 {
            return Err(format!("expected {expected_parts} parts, got {}", parts.len(), expected_parts = 4));
        }
        if parts[0] != "users" {
            return Err(format!("expected 'users' at position 0, got '{part}'", part = parts[0]));
        }
        let user = parts[1].to_string();
        if parts[2] != "shelves" {
            return Err(format!("expected 'shelves' at position 2, got '{part}'", part = parts[2]));
        }
        let shelf = parts[3].to_string();
        let result = Self {
            user,
            shelf,
        };
        result.validate()?;
        Ok(result)
    }
}

/// Multi-pattern resource name for library.googleapis.com/Author
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AuthorResourceName {
    Authors(AuthorsAuthorResourceName),
}

impl AuthorResourceName {
    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "library.googleapis.com/Author"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        match self {
            AuthorResourceName::Authors(inner) => inner.contains_wildcard(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        match self {
            AuthorResourceName::Authors(inner) => inner.validate(),
        }
    }
}

impl fmt::Display for AuthorResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AuthorResourceName::Authors(inner) => write!(f, "{inner}"),
        }
    }
}

impl FromStr for AuthorResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Ok(parsed) = AuthorsAuthorResourceName::from_str(s) {
            return Ok(AuthorResourceName::Authors(parsed));
        }
        Err("no matching pattern".to_string())
    }
}

/// Parses a resource name string and returns the appropriate type.
pub fn parse_author_resource_name(name: &str) -> Result<AuthorResourceName, String> {
    AuthorResourceName::from_str(name)
}

/// Resource name for library.googleapis.com/Author
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AuthorsAuthorResourceName {
    pub author: String,
}

impl AuthorsAuthorResourceName {
    /// Creates a new AuthorsAuthorResourceName.
    pub fn new(
        author: impl Into<String>
    ) -> Self {
        Self {
            author: author.into(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        if self.author.is_empty() {
            return Err("author: empty".to_string());
        }
        if self.author.contains('/') {
            return Err("author: contains illegal character '/'".to_string());
        }
        Ok(())
    }

    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "library.googleapis.com/Author"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        self.author == "-"
    }

}

impl fmt::Display for AuthorsAuthorResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "authors/{author}"
            , author = self.author
        )
    }
}

impl FromStr for AuthorsAuthorResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.split('/').collect();
        if parts.len() != 2 {
            return Err(format!("expected {expected_parts} parts, got {}", parts.len(), expected_parts = 2));
        }
        if parts[0] != "authors" {
            return Err(format!("expected 'authors' at position 0, got '{part}'", part = parts[0]));
        }
        let author = parts[1].to_string();
        let result = Self {
            author,
        };
        result.validate()?;
        Ok(result)
    }
}

/// Resource name for library.googleapis.com/Review
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReviewResourceName {
    pub project: String,
    pub book: String,
    pub review: String,
}

impl ReviewResourceName {
    /// Creates a new ReviewResourceName.
    pub fn new(
        project: impl Into<String>,
        book: impl Into<String>,
        review: impl Into<String>
    ) -> Self {
        Self {
            project: project.into(),
            book: book.into(),
            review: review.into(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        if self.project.is_empty() {
            return Err("project: empty".to_string());
        }
        if self.project.contains('/') {
            return Err("project: contains illegal character '/'".to_string());
        }
        if self.book.is_empty() {
            return Err("book: empty".to_string());
        }
        if self.book.contains('/') {
            return Err("book: contains illegal character '/'".to_string());
        }
        if self.review.is_empty() {
            return Err("review: empty".to_string());
        }
        if self.review.contains('/') {
            return Err("review: contains illegal character '/'".to_string());
        }
        Ok(())
    }

    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "library.googleapis.com/Review"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        self.project == "-" || self.book == "-" || self.review == "-"
    }

}

impl fmt::Display for ReviewResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "projects/{project}/books/{book}/reviews/{review}"
            , project = self.project
            , book = self.book
            , review = self.review
        )
    }
}

impl FromStr for ReviewResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.split('/').collect();
        if parts.len() != 6 {
            return Err(format!("expected {expected_parts} parts, got {}", parts.len(), expected_parts = 6));
        }
        if parts[0] != "projects" {
            return Err(format!("expected 'projects' at position 0, got '{part}'", part = parts[0]));
        }
        let project = parts[1].to_string();
        if parts[2] != "books" {
            return Err(format!("expected 'books' at position 2, got '{part}'", part = parts[2]));
        }
        let book = parts[3].to_string();
        if parts[4] != "reviews" {
            return Err(format!("expected 'reviews' at position 4, got '{part}'", part = parts[4]));
        }
        let review = parts[5].to_string();
        let result = Self {
            project,
            book,
            review,
        };
        result.validate()?;
        Ok(result)
    }
}

/// Multi-pattern resource name for library.googleapis.com/Publisher
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PublisherResourceName {
    Publishers(PublishersPublisherResourceName),
    Organizations(OrganizationsPublisherResourceName),
    Projects(ProjectsPublisherResourceName),
}

impl PublisherResourceName {
    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "library.googleapis.com/Publisher"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        match self {
            PublisherResourceName::Publishers(inner) => inner.contains_wildcard(),
            PublisherResourceName::Organizations(inner) => inner.contains_wildcard(),
            PublisherResourceName::Projects(inner) => inner.contains_wildcard(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        match self {
            PublisherResourceName::Publishers(inner) => inner.validate(),
            PublisherResourceName::Organizations(inner) => inner.validate(),
            PublisherResourceName::Projects(inner) => inner.validate(),
        }
    }
}

impl fmt::Display for PublisherResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PublisherResourceName::Publishers(inner) => write!(f, "{inner}"),
            PublisherResourceName::Organizations(inner) => write!(f, "{inner}"),
            PublisherResourceName::Projects(inner) => write!(f, "{inner}"),
        }
    }
}

impl FromStr for PublisherResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Ok(parsed) = PublishersPublisherResourceName::from_str(s) {
            return Ok(PublisherResourceName::Publishers(parsed));
        }
        if let Ok(parsed) = OrganizationsPublisherResourceName::from_str(s) {
            return Ok(PublisherResourceName::Organizations(parsed));
        }
        if let Ok(parsed) = ProjectsPublisherResourceName::from_str(s) {
            return Ok(PublisherResourceName::Projects(parsed));
        }
        Err("no matching pattern".to_string())
    }
}

/// Parses a resource name string and returns the appropriate type.
pub fn parse_publisher_resource_name(name: &str) -> Result<PublisherResourceName, String> {
    PublisherResourceName::from_str(name)
}

/// Resource name for library.googleapis.com/Publisher
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PublishersPublisherResourceName {
    pub publisher: String,
}

impl PublishersPublisherResourceName {
    /// Creates a new PublishersPublisherResourceName.
    pub fn new(
        publisher: impl Into<String>
    ) -> Self {
        Self {
            publisher: publisher.into(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        if self.publisher.is_empty() {
            return Err("publisher: empty".to_string());
        }
        if self.publisher.contains('/') {
            return Err("publisher: contains illegal character '/'".to_string());
        }
        Ok(())
    }

    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "library.googleapis.com/Publisher"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        self.publisher == "-"
    }

}

impl fmt::Display for PublishersPublisherResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "publishers/{publisher}"
            , publisher = self.publisher
        )
    }
}

impl FromStr for PublishersPublisherResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.split('/').collect();
        if parts.len() != 2 {
            return Err(format!("expected {expected_parts} parts, got {}", parts.len(), expected_parts = 2));
        }
        if parts[0] != "publishers" {
            return Err(format!("expected 'publishers' at position 0, got '{part}'", part = parts[0]));
        }
        let publisher = parts[1].to_string();
        let result = Self {
            publisher,
        };
        result.validate()?;
        Ok(result)
    }
}

/// Resource name for library.googleapis.com/Publisher
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OrganizationsPublisherResourceName {
    pub organization: String,
    pub publisher: String,
}

impl OrganizationsPublisherResourceName {
    /// Creates a new OrganizationsPublisherResourceName.
    pub fn new(
        organization: impl Into<String>,
        publisher: impl Into<String>
    ) -> Self {
        Self {
            organization: organization.into(),
            publisher: publisher.into(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        if self.organization.is_empty() {
            return Err("organization: empty".to_string());
        }
        if self.organization.contains('/') {
            return Err("organization: contains illegal character '/'".to_string());
        }
        if self.publisher.is_empty() {
            return Err("publisher: empty".to_string());
        }
        if self.publisher.contains('/') {
            return Err("publisher: contains illegal character '/'".to_string());
        }
        Ok(())
    }

    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "library.googleapis.com/Publisher"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        self.organization == "-" || self.publisher == "-"
    }

}

impl fmt::Display for OrganizationsPublisherResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "organizations/{organization}/publishers/{publisher}"
            , organization = self.organization
            , publisher = self.publisher
        )
    }
}

impl FromStr for OrganizationsPublisherResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.split('/').collect();
        if parts.len() != 4 {
            return Err(format!("expected {expected_parts} parts, got {}", parts.len(), expected_parts = 4));
        }
        if parts[0] != "organizations" {
            return Err(format!("expected 'organizations' at position 0, got '{part}'", part = parts[0]));
        }
        let organization = parts[1].to_string();
        if parts[2] != "publishers" {
            return Err(format!("expected 'publishers' at position 2, got '{part}'", part = parts[2]));
        }
        let publisher = parts[3].to_string();
        let result = Self {
            organization,
            publisher,
        };
        result.validate()?;
        Ok(result)
    }
}

/// Resource name for library.googleapis.com/Publisher
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ProjectsPublisherResourceName {
    pub project: String,
    pub publisher: String,
}

impl ProjectsPublisherResourceName {
    /// Creates a new ProjectsPublisherResourceName.
    pub fn new(
        project: impl Into<String>,
        publisher: impl Into<String>
    ) -> Self {
        Self {
            project: project.into(),
            publisher: publisher.into(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        if self.project.is_empty() {
            return Err("project: empty".to_string());
        }
        if self.project.contains('/') {
            return Err("project: contains illegal character '/'".to_string());
        }
        if self.publisher.is_empty() {
            return Err("publisher: empty".to_string());
        }
        if self.publisher.contains('/') {
            return Err("publisher: contains illegal character '/'".to_string());
        }
        Ok(())
    }

    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "library.googleapis.com/Publisher"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        self.project == "-" || self.publisher == "-"
    }

}

impl fmt::Display for ProjectsPublisherResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "projects/{project}/publishers/{publisher}"
            , project = self.project
            , publisher = self.publisher
        )
    }
}

impl FromStr for ProjectsPublisherResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.split('/').collect();
        if parts.len() != 4 {
            return Err(format!("expected {expected_parts} parts, got {}", parts.len(), expected_parts = 4));
        }
        if parts[0] != "projects" {
            return Err(format!("expected 'projects' at position 0, got '{part}'", part = parts[0]));
        }
        let project = parts[1].to_string();
        if parts[2] != "publishers" {
            return Err(format!("expected 'publishers' at position 2, got '{part}'", part = parts[2]));
        }
        let publisher = parts[3].to_string();
        let result = Self {
            project,
            publisher,
        };
        result.validate()?;
        Ok(result)
    }
}

