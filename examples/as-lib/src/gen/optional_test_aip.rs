// Code generated by protoc-gen-rust-aip. DO NOT EDIT.
//
// versions:
// 	protoc-gen-rust-aip development
// 	protoc (unknown)
// source: optional_test.proto

/// Resource name for test.googleapis.com/TestResource
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TestResourceResourceName {
    pub project: String,
    pub test: String,
}

impl TestResourceResourceName {
    /// Creates a new TestResourceResourceName.
    pub fn new(
        project: impl Into<String>,
        test: impl Into<String>
    ) -> Self {
        Self {
            project: project.into(),
            test: test.into(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        if self.project.is_empty() {
            return Err("project: empty".to_string());
        }
        if self.project.contains('/') {
            return Err("project: contains illegal character '/'".to_string());
        }
        if self.test.is_empty() {
            return Err("test: empty".to_string());
        }
        if self.test.contains('/') {
            return Err("test: contains illegal character '/'".to_string());
        }
        Ok(())
    }

    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "test.googleapis.com/TestResource"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        self.project == "-" || self.test == "-"
    }

}

impl fmt::Display for TestResourceResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "projects/{project}/tests/{test}"
            , project = self.project
            , test = self.test
        )
    }
}

impl FromStr for TestResourceResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.split('/').collect();
        if parts.len() != 4 {
            return Err(format!("expected {expected_parts} parts, got {}", parts.len(), expected_parts = 4));
        }
        if parts[0] != "projects" {
            return Err(format!("expected 'projects' at position 0, got '{part}'", part = parts[0]));
        }
        let project = parts[1].to_string();
        if parts[2] != "tests" {
            return Err(format!("expected 'tests' at position 2, got '{part}'", part = parts[2]));
        }
        let test = parts[3].to_string();
        let result = Self {
            project,
            test,
        };
        result.validate()?;
        Ok(result)
    }
}

