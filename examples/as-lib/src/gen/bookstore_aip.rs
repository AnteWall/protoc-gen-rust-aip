// Code generated by protoc-gen-rust-aip. DO NOT EDIT.
//
// versions:
// 	protoc-gen-rust-aip development
// 	protoc (unknown)
// source: bookstore.proto

/// Resource name for bookstore.googleapis.com/Store
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StoreResourceName {
    pub store: String,
}

impl StoreResourceName {
    /// Creates a new StoreResourceName.
    pub fn new(
        store: impl Into<String>
    ) -> Self {
        Self {
            store: store.into(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        if self.store.is_empty() {
            return Err("store: empty".to_string());
        }
        if self.store.contains('/') {
            return Err("store: contains illegal character '/'".to_string());
        }
        Ok(())
    }

    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "bookstore.googleapis.com/Store"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        self.store == "-"
    }

}

impl fmt::Display for StoreResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "stores/{store}"
            , store = self.store
        )
    }
}

impl FromStr for StoreResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.split('/').collect();
        if parts.len() != 2 {
            return Err(format!("expected {expected_parts} parts, got {}", parts.len(), expected_parts = 2));
        }
        if parts[0] != "stores" {
            return Err(format!("expected 'stores' at position 0, got '{part}'", part = parts[0]));
        }
        let store = parts[1].to_string();
        let result = Self {
            store,
        };
        result.validate()?;
        Ok(result)
    }
}

/// Resource name for bookstore.googleapis.com/Category
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CategoryResourceName {
    pub store: String,
    pub category: String,
}

impl CategoryResourceName {
    /// Creates a new CategoryResourceName.
    pub fn new(
        store: impl Into<String>,
        category: impl Into<String>
    ) -> Self {
        Self {
            store: store.into(),
            category: category.into(),
        }
    }

    /// Validates the resource name.
    pub fn validate(&self) -> Result<(), String> {
        if self.store.is_empty() {
            return Err("store: empty".to_string());
        }
        if self.store.contains('/') {
            return Err("store: contains illegal character '/'".to_string());
        }
        if self.category.is_empty() {
            return Err("category: empty".to_string());
        }
        if self.category.contains('/') {
            return Err("category: contains illegal character '/'".to_string());
        }
        Ok(())
    }

    /// Returns the resource type.
    pub fn resource_type(&self) -> &'static str {
        "bookstore.googleapis.com/Category"
    }

    /// Returns true if any field contains a wildcard.
    pub fn contains_wildcard(&self) -> bool {
        self.store == "-" || self.category == "-"
    }

}

impl fmt::Display for CategoryResourceName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "stores/{store}/categories/{category}"
            , store = self.store
            , category = self.category
        )
    }
}

impl FromStr for CategoryResourceName {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.split('/').collect();
        if parts.len() != 4 {
            return Err(format!("expected {expected_parts} parts, got {}", parts.len(), expected_parts = 4));
        }
        if parts[0] != "stores" {
            return Err(format!("expected 'stores' at position 0, got '{part}'", part = parts[0]));
        }
        let store = parts[1].to_string();
        if parts[2] != "categories" {
            return Err(format!("expected 'categories' at position 2, got '{part}'", part = parts[2]));
        }
        let category = parts[3].to_string();
        let result = Self {
            store,
            category,
        };
        result.validate()?;
        Ok(result)
    }
}

