package main

import (
    "fmt"
    "io"
    "log"
    "os"
    "strings"

    "google.golang.org/protobuf/proto"
    "google.golang.org/protobuf/types/descriptorpb"
    "google.golang.org/protobuf/types/pluginpb"
    "google.golang.org/genproto/googleapis/api/annotations"
)

func main() {
    // Read CodeGeneratorRequest from stdin
    input, err := io.ReadAll(os.Stdin)
    if err != nil {
        log.Fatalf("Failed to read input: %v", err)
    }

    var req pluginpb.CodeGeneratorRequest
    if err := proto.Unmarshal(input, &req); err != nil {
        log.Fatalf("Failed to unmarshal request: %v", err)
    }

    // Create response
    resp := &pluginpb.CodeGeneratorResponse{
        SupportedFeatures: proto.Uint64(uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)),
    }

    // Process files
    for _, file := range req.ProtoFile {
        if shouldGenerateForFile(file.GetName(), req.FileToGenerate) {
            if output := processFile(file); output != "" {
                resp.File = append(resp.File, &pluginpb.CodeGeneratorResponse_File{
                    Name:    proto.String(getOutputFileName(file.GetName())),
                    Content: proto.String(output),
                })
            }
        }
    }

    // Write response to stdout
    output, err := proto.Marshal(resp)
    if err != nil {
        log.Fatalf("Failed to marshal response: %v", err)
    }

    if _, err := os.Stdout.Write(output); err != nil {
        log.Fatalf("Failed to write output: %v", err)
    }
}

func shouldGenerateForFile(fileName string, filesToGenerate []string) bool {
    for _, f := range filesToGenerate {
        if f == fileName {
            return true
        }
    }
    return false
}

func getOutputFileName(protoFile string) string {
    if strings.HasSuffix(protoFile, ".proto") {
        return strings.TrimSuffix(protoFile, ".proto") + "_resources.rs"
    }
    return protoFile + "_resources.rs"
}

func processFile(file *descriptorpb.FileDescriptorProto) string {
    var resources []ResourceInfo
    
    // Process all messages in the file
    for _, msg := range file.MessageType {
        if resource := extractResourceFromMessage(msg, file.GetName()); resource != nil {
            resources = append(resources, *resource)
        }
        
        // Process nested messages recursively
        processNestedMessages(msg.NestedType, file.GetName(), &resources)
    }
    
    if len(resources) == 0 {
        return ""
    }
    
    // Generate Rust code (legacy: generator currently emits Rust-formatted helpers)
    return generateRustCode(resources, file.GetPackage())
}

func processNestedMessages(messages []*descriptorpb.DescriptorProto, fileName string, resources *[]ResourceInfo) {
    for _, msg := range messages {
        if resource := extractResourceFromMessage(msg, fileName); resource != nil {
            *resources = append(*resources, *resource)
        }
        processNestedMessages(msg.NestedType, fileName, resources)
    }
}

type ResourceInfo struct {
    MessageName string
    TypeName    string
    Patterns    []string
    Singular    string
    Plural      string
    History     string // Changed from []string to string since it's an enum
}

func extractResourceFromMessage(msg *descriptorpb.DescriptorProto, fileName string) *ResourceInfo {
    if msg.Options == nil {
        return nil
    }
    
    // Try to get the google.api.resource extension
    if !proto.HasExtension(msg.Options, annotations.E_Resource) {
        return nil
    }
    
    resourceExt, ok := proto.GetExtension(msg.Options, annotations.E_Resource).(*annotations.ResourceDescriptor)
    if !ok || resourceExt == nil {
        return nil
    }
    
    fmt.Fprintf(os.Stderr, "DEBUG: Found resource extension for %s: type=%s, patterns=%v\n", 
        msg.GetName(), resourceExt.GetType(), resourceExt.GetPattern())
    
    return &ResourceInfo{
        MessageName: msg.GetName(),
        TypeName:    resourceExt.GetType(),
        Patterns:    resourceExt.GetPattern(),
        Singular:    resourceExt.GetSingular(),
        Plural:      resourceExt.GetPlural(),
        History:     resourceExt.GetHistory().String(),
    }
}

func generateRustCode(resources []ResourceInfo, packageName string) string {
    var sb strings.Builder
    
    sb.WriteString("// Generated by protoc-gen-rust-aip\n")
    sb.WriteString("// DO NOT EDIT\n\n")
    
    if packageName != "" {
        sb.WriteString(fmt.Sprintf("// Package: %s\n\n", packageName))
    }
    
    sb.WriteString("use std::fmt;\n")
    sb.WriteString("use std::str::FromStr;\n\n")
    
    for _, resource := range resources {
        generateResourceStruct(&sb, &resource)
        sb.WriteString("\n")
    }
    
    return sb.String()
}

func generateResourceStruct(sb *strings.Builder, resource *ResourceInfo) {
    // Generate a Rust struct for the resource name
    structName := toRustTypeName(resource.TypeName)
    
    sb.WriteString(fmt.Sprintf("/// Resource name for %s\n", resource.TypeName))
    sb.WriteString(fmt.Sprintf("/// Patterns: %v\n", resource.Patterns))
    sb.WriteString("#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n")
    sb.WriteString(fmt.Sprintf("pub struct %s {\n", structName))
    sb.WriteString("    raw: String,\n")
    sb.WriteString("}\n\n")
    
    // Generate implementation
    sb.WriteString(fmt.Sprintf("impl %s {\n", structName))
    sb.WriteString("    pub fn new(name: impl Into<String>) -> Self {\n")
    sb.WriteString("        Self { raw: name.into() }\n")
    sb.WriteString("    }\n\n")
    sb.WriteString("    pub fn as_str(&self) -> &str {\n")
    sb.WriteString("        &self.raw\n")
    sb.WriteString("    }\n")
    sb.WriteString("}\n\n")
    
    // Generate Display trait
    sb.WriteString(fmt.Sprintf("impl fmt::Display for %s {\n", structName))
    sb.WriteString("    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n")
    sb.WriteString("        write!(f, \"{}\", self.raw)\n")
    sb.WriteString("    }\n")
    sb.WriteString("}\n\n")
    
    // Generate FromStr trait
    sb.WriteString(fmt.Sprintf("impl FromStr for %s {\n", structName))
    sb.WriteString("    type Err = String;\n\n")
    sb.WriteString("    fn from_str(s: &str) -> Result<Self, Self::Err> {\n")
    sb.WriteString("        // TODO: Add pattern validation\n")
    sb.WriteString("        Ok(Self::new(s))\n")
    sb.WriteString("    }\n")
    sb.WriteString("}\n\n")
    
    // Generate From<String> trait
    sb.WriteString(fmt.Sprintf("impl From<String> for %s {\n", structName))
    sb.WriteString("    fn from(s: String) -> Self {\n")
    sb.WriteString("        Self::new(s)\n")
    sb.WriteString("    }\n")
    sb.WriteString("}\n\n")
}

func toRustTypeName(googleApiType string) string {
    // Convert "pubsub.googleapis.com/Topic" to "PubsubTopic"
    // Remove the domain part and convert to PascalCase
    if idx := strings.LastIndex(googleApiType, "/"); idx != -1 {
        typeName := googleApiType[idx+1:]
        return toPascalCase(typeName)
    }
    return toPascalCase(googleApiType)
}

func toPascalCase(s string) string {
    words := strings.FieldsFunc(s, func(r rune) bool {
        return r == '_' || r == '-' || r == '.' || r == ' '
    })
    
    result := ""
    for _, word := range words {
        if len(word) > 0 {
            result += strings.ToUpper(word[:1]) + strings.ToLower(word[1:])
        }
    }
    return result
}
